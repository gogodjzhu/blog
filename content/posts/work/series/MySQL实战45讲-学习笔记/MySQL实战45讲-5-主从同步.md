---
title: "MySQL实战45讲(5)-主从同步"
date: 2021-04-01T17:45:11+08:00
description: ""
tags: ["MySQL", "网课笔记"]
categories: "MySQL实战45讲"
draft: true



---

> 系列文章源自极客时间[《MySQL实战45讲》](http://gk.link/a/10pWf)课程的学习整理。

## 简介

MySQL提供一套主从同步机制，这套机制的基础是binlog，主库将所有修改保存到binlog并主动发送到从库，从库将binlog在本地重做一遍以实现状态同步。

![img](https://www.gogodjzhu.com/wp-content/uploads/2019/11/1a85a3bac30a32438bfd8862e5a34eef.png)主从库通过binlog实现数据同步

上图比较完整地描绘了数据在主从库间的流动过程，本文主要围绕途中几个关键节点展开：

- binlog如何从主库流向从库？binlog在从库是怎样重做的？
- 数据由主库流向从库的延迟处理策略？
- 主从切换怎么做？

### binlog传输策略



### 主从延迟问题

说起主从延迟就不得不提一个很重要的参数，`Seconds_Behind_Master(SBM)`它表征的是同一个事务，在从库执行完成的时间和主库完成时间的差值。可以在从库上执行`show slave status`命令看到这个值，单位为秒。
`SBM`的计算方法为：主库在生成binlog保存事务时会多保存一个时间字段，从库拿到binlog执行该事务时取出这个时间，与当前时间计算。

结合前述，从SBM的角度来看，主从延迟的来源主要是以下几个时间节点之间的差值：

1. 主库记录主库执行时间生成binlog T1
2. 主库通过网络将binlog发送给从库保存为relay log T2
3. 从库解析relay log执行事务 T3

> 系统时间对SBM的影响
>
>  一般来说，其中T3-T1是SBM的值，但如果主从时间不同步，计算出来的SBM也会由偏差。 

T2-T1这个时间段的差值主要受网络带宽影响，正常情况下，这个时间段是比较短的。主要的延迟来自于T3-T2，即relay log已经在从库完成保存后，从库通过sql_thread处理这些relay log耗费的时间。导致这个时间过长的原因常见有：

1. 从库机器性能比主库差（这种差可能是机器配置的，也有可能是从库上其他进程占用资源过多导致的），导致同样的sql在从库执行的比较慢
2. 备库因为处理过多同步之外的工作（比如读写分离时，在从库做太多的查询分析操作），导致压力过大。
3. 大事务导致从库执行时间过长，阻塞了新到事务的执行导致延迟。
   - 常见的大事务例如delete语句覆盖太多数据；大表DDL语句。
4. 主库多事务并行，从库却因为一些原因导致串行执行这些事务。

这几个导致主从延迟的原因，
1，2是环境问题，这里不做讨论。
3是需要开发人员尽量注意避免的，比如delete数据时尽可能控制影响的数据行数，分批删除减小事务；如果需要清空/删除整表，使用truncate/drop命令代替。大表DDL尽量避免，或者使用不会产生大事务的替代方案曲线救国（比如gh-ost）。

而第4点，在5.6版本之前从库执行relay-log只支持单线程串行执行，在新版本多次优化了多线程并行复制策略。

#### 并行复制策略

并行复制的想法很直接，就是在从库重放relay-log的时候，把事务或者行的操作在多个线程并发。但要面对的问题却不少。由于多线程执行的顺序不确定，导致从单个binlog中解析出来的多个事务（行）操作落到每个线程中执行的顺序可能不同于主库，这就会导致数据不一致。因此我们可以这样要求：

1. 对同一行数据的操作，不能乱序，需要落到同一个线程去执行。
2. 一个事务内的多个行操作不能拆开，只能落到同一个线程。

在5.6版本的mysql中，提供了按库并行的并行复制功能。具体实现为：

- 将单线程sql_thread用coordinator替代，负责读取并解析relay-log得到事务。

- coordinator线程为每个worker线程维护一个hashmap，key是这个worker线程中正在处理（排队）的事务所涉及修改的DB，value是指向对应DB的事务数量。比如worker_1内有一个事务在操作库DB1，则hashmap内有DB1->1

- coordinator线程在给每个事务分配worker线程时，遵照以下策略：

  - 遍历事务中涉及的每个DB，到所有worker线程的hashmap中寻找是否存在。如果存在则称为冲突。

  - 如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker
  - 如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker
  - 如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个

这种策略的掣肘在于热点BD问题，在极端情况下，最繁忙的DB占据了大多的操作就会退化为单线程执行。为此在后续的版本中还对并行复制策略做了进一步的优化，这里不做展开。

### 主从切换



前面介绍了主从同步可能存在的延迟情况，那么自然的，在可能存在延迟的背景下，切换主从角色就需要考虑因为延迟带来的数据不一致问题。核心思路有两个：

1. 可靠性优先策略。通过SBM值判断从库落后主库的时间，切换的过程中中断主库的写服务，等到SBM将为0，认为从库追上主库，切换主从角色并使新主库可写。
   带来的问题首先就是切换过程不可写入。另外如果主库异常关闭导致主从切换，停留在主库未发送给从库的binlog将一直无法同步，为了保证可靠，那么从库也永远无法升级为主库。
2. 可用性优先策略。此策略优先考虑的就是让主从切换过程中的不可用时间尽可能短。自然可以想到的，这会带来数据一致性的问题。

> Seconds_Behind_Master vs. pt-heartbeat 差异
>
> SBM是从库在执行relay log的时候，将sql中记录的主库时间跟当前从库时间计算的差值。那么可能存在以下几种情况导致SMB无法真实表征同步情况：1.