---
title: "MySQL实战45讲(4)-事务 "
date: 2021-04-01T17:45:11+08:00
description: ""
tags: ["MySQL", "网课笔记"]
categories: "MySQL实战45讲"
draft: true




---

> 系列文章源自极客时间[《MySQL实战45讲》](http://gk.link/a/10pWf)课程的学习整理。



事务隔离关注的`ACID`中提到的I 即 Isolation, 常见的事务隔离级别有4中, 无需赘述:

- 读未提交，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

> Mysql/Oracle默认隔离级别
>
> Mysql默认使用可重复读, Oracle为读提交. 所以数据库迁移的时候需要关注手动定义隔离级别.

## 事务隔离的实现

对于读未提交, 由于使用得很少, 这里不做讨论.
对于串行化, 主要通过锁的方式来控制事务隔离. 所有的select语句被隐式转为select … lock in share mode.
Mysql使用可重复读作为默认隔离级别, 我们着重展开.

核心技术是MVCC (Multiple Version Concurrent Control, 多版本并发控制), 引用一张图来说明,

![img](https://www.gogodjzhu.com/wp-content/uploads/2019/09/d9c313809e5ac148fc39feff532f0fee.png)从右往左看, 同一个记录的多个版本值

在一个事务内修改数据, 通过将当前值拷贝为一个镜像, 在这个镜像上的每次修改按照版本号保存为多条隐式的数据. 其余事务读数据还是读的原值. 这样实现了读写的并发.

> 并发控制的发展思路
>
> \1. **普通锁**，本质是串行执行
> **2. 读写锁**，可以实现读读并发
> **3. 数据多版本**，可以实现读写并发

### redo / undo 日志

MVCC是通过数据版本来实现并发控制的一个设计方案, 每条数据会额外保存以下3个隐藏字段:

| DB_TRX_ID | 保存 |
| --------- | ---- |
|           |      |
|           |      |

`redo日志`用于保存已提交事务中的操作, 用于持久化保存, 防止数据丢失. 采用顺序append写入, 由于顺序写入, 效率高, 需要在合适的时候merge回数据文件(ibdata). 在系统崩溃重启时, 需要先重做所有未合并回数据文件的redo操作.

`undo日志`用于保存未提交事务内会修改数据的操作, 比如INSERT/UPDATE/DELETE, 当