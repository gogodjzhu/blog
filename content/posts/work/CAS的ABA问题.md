---
title: "CAS的ABA问题"
date: 2019-11-05T08:27:11+08:00
description: "ABA问题常发生在链表"
tags: ["算法", "数据结构"]
draft: true
---

ABA问题本身并没有什么难理解的，可以简单用一句话来概括：线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。

当然，如果仅仅关心最终的值是否符合预期，ABA问题并没有什么影响，*这也是为什么大多数情况下我们依然可以使用AtomicInteger等数值CAS类不出问题的原因*。

但是如果CAS操作的内存对象包含数值之外的意义，比如说链表之间的引用，就可能出现bug。比如链表`A->B->C`，执行操作`CAS(A,B)`, 将链表头换成`B`，如果操作过程中其他线程将链表变成`A->C`，执行`CAS(A,B)`的线程发现连表头`A`并没有改变，修改成功，导致链表变成`B->null`，这在某些情况下就会出现问题。

```java
// 初始状态
A -> B -> C -> null

// 线程1执行CAS(A,B)，即判断链表头为A时将其改为B，期待的结果为:
B -> C -> null

// 线程2将链表改为:
A -> C -> null
其中B已经成了独立节点:
B -> null

// 回到线程1执行CAS(A,B)面对的是`A -> C -> null`，仍然满足链表头为A的条件故将其改为B，实际结果与预期不符，为：
B -> null

```



ABA的问题本质上是由于CAS在执行Compare的时候，比较的信息不够充分导致的。前例修改链表，比较链表头的时候仅仅比较了链表头的值是否变更（是否仍为`A`），忽略了链表头`next`属性的变化。如果我们在做比较的时候，进一步比较链表头的下级是否变化，自然可以发现A其实发生了变化，Caompare结果应该为`false`。

更常见的解决ABA问题的方法是增加版本属性，每次修改后版本相应变化，那么在做Compare的时候对版本也做一次校验，自然就可以解决ABA问题。JDK中提供了`AtomicStampedReference`带版本校验的CAS实现。

更普遍地，可以将ABA问题出现的原因归结为`对A的属性进行的校验不够充分`，链表的例子中节点实际包含两个属性为`节点值`和`节点后继关系`。而版本号则是将所有属性进行统一管理，所以比较版本号才能够代替对每个属性的单独比较，方便，高效。